<!DOCTYPE html>
<html lang="en">
<script src="https://cdn.jsdelivr.net/npm/mathjs@11.8.0/lib/browser/math.min.js"></script>
<meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Interactive Bloch Sphere</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #000;
      color: white;
      font-family: sans-serif;
      position: relative;
      height: 100vh;
    }
    #controls {
      z-index: 10;
      z-index: 1;

      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.6);
      padding: 10px;
      border-radius: 8px;
    }
    label, input, button {
      display: block;
      margin: 6px 0;
    }
    input[type=range] {
      width: 200px;
    }
    .gate-btn {
      margin: 4px 4px;
      padding: 4px 10px;
      font-size: 0.9rem;
    }
  </style>
</head>
<body>
  <div id="controls">
    <div id="statevector" style="margin-top:10px;font-size:0.85rem">
      <strong>State Vector:</strong>
      <div id="psiVal">|ψ⟩ = ?</div>
    </div>
    <label>Theta (θ): <span id="thetaVal">0</span></label>
    <input type="range" id="theta" min="0" max="3.1415" step="0.01" value="0">

    <label>Phi (φ): <span id="phiVal">0</span></label>
    <input type="range" id="phi" min="0" max="6.283" step="0.01" value="0">

    <button id="randomizeBtn">Randomize State</button>
    <button id="resetBtn">Reset to |0⟩</button>

    <div>
      <strong>Quantum Gates:</strong><br />
      <button class="gate-btn" id="xGate">X</button>
      <button class="gate-btn" id="yGate">Y</button>
      <button class="gate-btn" id="zGate">Z</button>
      <button class="gate-btn" id="hGate">H</button>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'https://esm.sh/three@0.160.0';
import { OrbitControls } from 'https://esm.sh/three@0.160.0/examples/jsm/controls/OrbitControls';
const math = window.math;

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 3;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);
    renderer.domElement.style.position = 'fixed';
    renderer.domElement.style.top = '0';
    renderer.domElement.style.zIndex = '0';
    renderer.domElement.style.left = '0';

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const sphereGeometry = new THREE.SphereGeometry(1, 64, 64);
    const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0x00aaff, wireframe: true });
    const blochSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
    scene.add(blochSphere);

    function createFullAxis(dir, color) {
      const lineMaterial = new THREE.LineBasicMaterial({ color });
      const points = [dir.clone().multiplyScalar(-1.2), dir.clone().multiplyScalar(1.2)];
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const line = new THREE.Line(geometry, lineMaterial);
      scene.add(line);
    }

    createFullAxis(new THREE.Vector3(1, 0, 0), 0xff0000);
    createFullAxis(new THREE.Vector3(0, 1, 0), 0x00ff00);
    createFullAxis(new THREE.Vector3(0, 0, 1), 0x0000ff);

    const labelStyle = { color: '#ffffff', fontSize: '14px' };
    function createLabel(text, position) {
      const div = document.createElement('div');
      div.style.position = 'absolute';
      div.style.color = labelStyle.color;
      div.style.fontSize = labelStyle.fontSize;
      div.innerHTML = text;
      document.body.appendChild(div);
      return { element: div, position };
    }

    const labels = [
      createLabel('|0⟩', new THREE.Vector3(0, 0, 1)), // north pole
      createLabel('|1⟩', new THREE.Vector3(0, 0, -1)), // south pole
      createLabel('|+⟩', new THREE.Vector3(1, 0, 0)),
      createLabel('|−⟩', new THREE.Vector3(-1, 0, 0)),
      createLabel('|i⟩', new THREE.Vector3(0, 1, 0)),
      createLabel('|−i⟩', new THREE.Vector3(0, -1, 0)),
    ];

    function updateLabelPositions() {
      labels.forEach(label => {
        const projected = label.position.clone().project(camera);
        const x = (projected.x * 0.5 + 0.5) * window.innerWidth;
        const y = (1 - (projected.y * 0.5 + 0.5)) * window.innerHeight;
        label.element.style.left = `${x}px`;
        label.element.style.top = `${y}px`;
        label.element.style.zIndex = '10';
        label.element.style.position = 'absolute';
        label.element.style.transform = 'translate(-50%, -50%)';
        label.element.style.pointerEvents = 'none';
        label.element.style.pointerEvents = 'none';
      });
    }

    let theta = 0, phi = 0;
    let stateVector = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, 0), 1, 0xffff00, 0.15, 0.08);
    scene.add(stateVector);

    function updateStateVectorFromAngles(t, p) {
      theta = t;
      phi = p;
      const x = Math.sin(theta) * Math.cos(phi);
      const y = Math.sin(theta) * Math.sin(phi);
      const z = Math.cos(theta); // z-axis = |0⟩ at north pole
      const dir = new THREE.Vector3(x, y, z).normalize();
      scene.remove(stateVector);
      stateVector = new THREE.ArrowHelper(dir, new THREE.Vector3(0, 0, 0), 1, 0xffff00, 0.15, 0.08);
      scene.add(stateVector);

      // Compute and display full state vector
      const alpha = math.complex(Math.cos(theta / 2), 0);
      const beta = math.complex({ abs: Math.sin(theta / 2), arg: phi });
      const pretty = (z) => {
        const re = z.re.toFixed(2);
        const im = z.im.toFixed(2);
        if (Math.abs(z.im) < 1e-2) return `${re}`;
        if (Math.abs(z.re) < 1e-2) return `${im}i`;
        return `(${re} ${z.im < 0 ? '-' : '+'} ${Math.abs(im)}i)`;
      };
      document.getElementById("psiVal").innerText = `|ψ⟩ = ${pretty(alpha)} |0⟩ + ${pretty(beta)} |1⟩`;
    }

    function applyMatrixGate(matrix) {
      const alpha = math.complex(Math.cos(theta / 2), 0);
      const beta = math.complex({
        abs: Math.sin(theta / 2),
        arg: phi
        });
      const a = math.complex(alpha);
      const b = math.complex(beta);
      const newAlpha = math.add(math.multiply(matrix[0][0], a), math.multiply(matrix[0][1], b));
      const newBeta = math.add(math.multiply(matrix[1][0], a), math.multiply(matrix[1][1], b));
      const inner = math.multiply(math.conj(newAlpha), newBeta);
      const x = 2 * math.re(inner);
      const y = 2 * math.im(inner);
      const z = Math.pow(math.abs(newAlpha), 2) - Math.pow(math.abs(newBeta), 2);
      const r = Math.sqrt(x * x + y * y + z * z);
      const newTheta = Math.acos(z / r);
      const newPhi = Math.atan2(y, x);
      thetaSlider.value = newTheta;
      phiSlider.value = newPhi;
      thetaVal.textContent = newTheta.toFixed(2);
      phiVal.textContent = newPhi.toFixed(2);
      updateStateVectorFromAngles(newTheta, newPhi);
    }

    function applyGate(gate) {
      const gates = {
        'X': [[0, 1], [1, 0]],
        'Y': [[0, math.complex(0, -1)], [math.complex(0, 1), 0]],
        'Z': [[1, 0], [0, -1]],
        'H': [[1 / Math.sqrt(2), 1 / Math.sqrt(2)], [1 / Math.sqrt(2), -1 / Math.sqrt(2)]]
      };
      applyMatrixGate(gates[gate]);
    }

    function resetToZero() {
      theta = 0;
      phi = 0;
      thetaSlider.value = theta;
      phiSlider.value = phi;
      thetaVal.textContent = theta.toFixed(2);
      phiVal.textContent = phi.toFixed(2);
      updateStateVectorFromAngles(theta, phi);
    }

    const thetaSlider = document.getElementById("theta");
    const phiSlider = document.getElementById("phi");
    const thetaVal = document.getElementById("thetaVal");
    const phiVal = document.getElementById("phiVal");
    const randomizeBtn = document.getElementById("randomizeBtn");
    const resetBtn = document.getElementById("resetBtn");

    document.getElementById("xGate").addEventListener("click", () => applyGate('X'));
    document.getElementById("yGate").addEventListener("click", () => applyGate('Y'));
    document.getElementById("zGate").addEventListener("click", () => applyGate('Z'));
    document.getElementById("hGate").addEventListener("click", () => applyGate('H'));
    resetBtn.addEventListener("click", resetToZero);

    thetaSlider.addEventListener("input", () => {
      theta = parseFloat(thetaSlider.value);
      phi = parseFloat(phiSlider.value);
      thetaVal.textContent = theta.toFixed(2);
      updateStateVectorFromAngles(theta, phi);
    });

    phiSlider.addEventListener("input", () => {
      theta = parseFloat(thetaSlider.value);
      phi = parseFloat(phiSlider.value);
      phiVal.textContent = phi.toFixed(2);
      updateStateVectorFromAngles(theta, phi);
    });

    randomizeBtn.addEventListener("click", () => {
      const t = Math.random() * Math.PI;
      const p = Math.random() * (2 * Math.PI);
      thetaSlider.value = t;
      phiSlider.value = p;
      thetaVal.textContent = t.toFixed(2);
      phiVal.textContent = p.toFixed(2);
      updateStateVectorFromAngles(t, p);
    });

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
      updateLabelPositions();
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
